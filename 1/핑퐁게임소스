const int row[8] = {  6,3,8,2,10,9,17,13 };const int col[8] = {  16,4,5,12,7,11,18,19  };int pixels[8][8];           const int mapMin = 0;const int mapMax = 7;int pongSize = 1; int pongMin = mapMin + pongSize;int pongMax = mapMin - pongSize;int pongX = 5;int pongX2 = 3;int pongXSpeed = 1;const int maxSpeed = 3;int ballXSpeed = 0;int ballYSpeed = 1;int ballX = pongX;int ballY = 1;int ballHits = 1;int counter = 0;int framerate = 200;int minFramerate = 100;boolean multiplayer = true;boolean reset = false;boolean player1Victory = false;boolean player2Victory = false;void setup() {  for (int thisPin = 0; thisPin < 8; thisPin++) {    pinMode(col[thisPin], OUTPUT);     pinMode(row[thisPin], OUTPUT);       digitalWrite(col[thisPin], HIGH);      }  for (int x = 0; x < 8; x++) {    for (int y = 0; y < 8; y++) {      pixels[x][y] = HIGH;    }  }}void loop() {  updatePaddle1();    if(multiplayer){    updatePaddle2();  }    if(!reset){    update();  }    refreshScreen(); }void update(){  counter = counter + 1;     if(counter >= framerate){    counter = 0;        if(ballHits%5 == 0){      if(framerate > minFramerate){        framerate -= 5;      }    }    }         if(counter == 0){    ballUpdate();    if(multiplayer == false){      updatePaddleAI();    }   }}void ballUpdate(){       pixels[ballX][ballY] = HIGH;    ballX += ballXSpeed;  ballY += ballYSpeed;    if(ballY == mapMin){    if(ballX <= pongX + pongSize && ballX >= pongX - pongSize){      ballYSpeed = -ballYSpeed;      if(ballXSpeed >= 0){        ballXSpeed = 1;      }else{        ballXSpeed = -1;       }      ballY += ballYSpeed;       ballHits += 1;            if(ballXSpeed > maxSpeed){        ballXSpeed = maxSpeed;       }    }  }else if(ballY == mapMax){    if(ballX <= pongX2 + pongSize && ballX >= pongX2 - pongSize){      ballYSpeed = -ballYSpeed;      if(ballXSpeed >= 0){        ballXSpeed = 1;      }else{        ballXSpeed = -1;       }      ballY += ballYSpeed;             if(ballXSpeed > maxSpeed){        ballXSpeed = maxSpeed;       }     }  }       if(ballX < mapMin){    ballX = mapMin;    ballXSpeed = -ballXSpeed;  }else if(ballX > mapMax){    ballX = mapMax;    ballXSpeed = -ballXSpeed;  }  if(ballY < mapMin){    reset = true;    player2Victory = true;  }else if(ballY > mapMax){    reset = true;    player1Victory = true;  }      pixels[ballX][ballY] = LOW;  }void updatePaddle1() {  int newPongX = 7 - map(analogRead(A0), 0, 1023, 0, 7);    if(newPongX - pongSize < mapMin) {    return;  }else if(newPongX + pongSize > mapMax) {    return;  }     setPongState(pongX, mapMin, HIGH);    pongX = newPongX;    if(player2Victory == false){    setPongState(pongX, mapMin, LOW);   }}void updatePaddle2() {  int newPongX = 7-map(analogRead(A1), 0, 1023, 0, 7);  if(newPongX - pongSize < mapMin) {    return;  }else if(newPongX + pongSize > mapMax) {    return;  }  setPongState(pongX2, mapMax, HIGH);    pongX2 = newPongX;    if(player1Victory == false){    setPongState(pongX2, mapMax, LOW);   }}void updatePaddleAI() {    if(ballY > 2 && ballYSpeed > 0){    if(pongX2 > ballX){      pongXSpeed = -1;    }else{      pongXSpeed = 1;    }  }    int newPongX = pongX2 + pongXSpeed;    if(newPongX - pongSize < mapMin) {    newPongX = mapMin + pongSize;  }else if(newPongX + pongSize > mapMax) {    newPongX = mapMax - pongSize;  }  setPongState(pongX2, mapMax, HIGH);  pongX2 = newPongX;  if(player1Victory == false){    setPongState(pongX2, mapMax, LOW);   }}void setPongState(int xPos, int yPos, int state) {   pixels[xPos][yPos] = state;  pixels[xPos - pongSize][yPos] = state;  pixels[xPos + pongSize][yPos] = state;}void refreshScreen() {  for (int thisRow = 0; thisRow < 8; thisRow++) {    digitalWrite(row[thisRow], HIGH);    for (int thisCol = 0; thisCol < 8; thisCol++) {           int thisPixel = pixels[thisRow][thisCol];      digitalWrite(col[thisCol], thisPixel);      if (thisPixel == LOW) {        digitalWrite(col[thisCol], HIGH);      }    }    digitalWrite(row[thisRow], LOW);  }}
